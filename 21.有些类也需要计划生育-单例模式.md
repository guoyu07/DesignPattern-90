+ 单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
+ 通常可以让一个全局变量使得一个对象被访问，但它不能阻止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以背创建，并且它可以提供一个访问该实例的方法。
+ 单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。
+ 实用类通常也会采用私有化的构造方法来避免其他实例。但它们还是有很多不同的，比如实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例类是有状态的。实用类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。实用类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。在运用中要仔细分析再决定用哪一种方式。

#### 静态初始化
+ “静态初始化”方法，不需要开发人员显式地编写线程安全代码，即可解决多线程环境下它是不安全的问题。

```
public sealed class Singleton   // sealed: 阻止发生派生，而派生可能会增加实例
{
  private static readonly Singleton instance = new Singleton();  //在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化
  private Singleton() {}
  public static Singleton GetInstance*(){
    return instance;
  }
}
```
