+ 单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
+ 通常可以让一个全局变量使得一个对象被访问，但它不能阻止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以背创建，并且它可以提供一个访问该实例的方法。
+ 单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。
+ 实用类通常也会采用私有化的构造方法来避免其他实例。但它们还是有很多不同的，比如实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例类是有状态的。实用类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。实用类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。在运用中要仔细分析再决定用哪一种方式。

#### 静态初始化
+ “静态初始化”方法，不需要开发人员显式地编写线程安全代码，即可解决多线程环境下它是不安全的问题。

```
public sealed class Singleton   // sealed: 阻止发生派生，而派生可能会增加实例
{
  private static readonly Singleton instance = new Singleton();  //在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化
  private Singleton() {}
  public static Singleton GetInstance*(){
    return instance;
  }
}
```
+ 该实现也解决了单例模式试图解决的两个级别问题：全局访问和实例化控制，公共静态属性为访问实例提供了一个全局访问点。不同之处在于它依赖公共语言运行库来初始化变量。由于构造方法是私有的，因此不能在类本身以外实例化Singleton类；因此，变量引用的是可以在系统中存在的唯一实例。
+ 需要注意的是，instance被标记为readonly，这意味着只能在静态初始化期间或在类构造函数中分配变量。
+ 饿汉式：静态初始化的方式，它是类一加载时就实例化的对象，所以要提起占用系统资源。
+ 懒汉式单例类：要在第一次被引用时，才会将自己实例化。会面临多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。
